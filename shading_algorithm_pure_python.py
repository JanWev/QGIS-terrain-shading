# -*- coding: utf-8 -*-

"""

/***************************************************************************
 DemShading
                                 A QGIS plugin
 This plugin simulates natural shadows over an elevation model (DEM)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-05
        copyright            : (C) 2019 by Zoran Čučković
        email                : cuckovic.zoran@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Zoran Čučković'
__date__ = '2019-06-05'
__copyright__ = '(C) 2019 by Zoran Čučković'

import gdal
import numpy as np
from .modules.helpers import window_loop, filter3


"""
This algorithm simulates natural shade over a raster DEM (in input). 
"""


ANALYSIS_TYPES = ['Depth', 'Reach']

output_model = None #for post processing

# ToDo: add all needed inputs
chunk_size = 5 # in mega pixel
dem_file = 'C:/Users/Jan/Desktop/work/IdePix/mountain_shadow/S2B_MSIL1C_20201122T102339_N0209_R065_T32TPT_20201122T113248_s2resampled_elevation.tif'
saa = 171.24
sza = 68.03
direction = saa
sun_angle = 90 - sza
# set smooth to False if no smoothing is wanted
smooth = True
dst_filename = 'C:/Users/Jan/Desktop/work/IdePix/mountain_shadow/S2B_MSIL1C_20201122T102339_N0209_R065_T32TPT_20201122T113248_s2resampled_elevation_shadow_python.tif'


def processAlgorithm(chunk_size, dem_file, direction, sun_angle, smooth):
    """
    Here is where the processing itself takes place.
    """

    # 2)   --------------- ORIENTATION AND DIMENSIONS -----------------
    steep =  (45 <= direction <= 135 or 225 <= direction <= 315)

    s = direction % 90
    if s > 45: s= 90-s

    slope = np.tan(np.radians(s ))# matrix shear slope
    tilt= np.tan(np.radians(sun_angle))

    dem = gdal.Open(dem_file)

    # ! attention: x in gdal is y dimension un numpy (the first dimension)
    xsize, ysize = dem.RasterXSize,dem.RasterYSize
    # assuming one band dem !
    nodata = dem.GetRasterBand(1).GetNoDataValue()

    pixel_size = dem.GetGeoTransform()[1]

    chunk = int(chunk_size) * 1000000
    chunk = min(chunk // (ysize if steep else xsize), (xsize if steep else ysize))

    if s%45 > 0 :
        # Determine the optimal chunk size (estimate!).
        # The problem is to carry rasterized lines
        # from one chunk to another.
        # So, set chunk size according to minimum rasterisation error
        c = (np.arange(1, chunk) * slope) % 1 # %1 to get decimals only
        c[c>0.5] -= 1
        # this is not ideal : we cannot predict where it would stop
        chunk -= np.argmin(np.round(abs(c), decimals = 2)[::-1])+1

    # writing output beforehand, to prepare for data dumps
    driver = gdal.GetDriverByName('GTiff')
    ds = driver.Create(dst_filename, xsize,ysize, 1, gdal.GDT_Float32)
    ds.SetProjection(dem.GetProjection())
    ds.SetGeoTransform(dem.GetGeoTransform())

    # 3) -------   SHEAR MATRIX (INDICES) -------------

    chunk_slice = (ysize, chunk) if steep else ( chunk, xsize)
    indices_y, indices_x = np.indices(chunk_slice)
    mx_z = np.zeros( chunk_slice); mx_z[:] = -99999

    # this is all upside down ...
    rev_y= 90 <= direction <= 270
    rev_x= not 180 <= direction <= 360

    if rev_y: indices_y = indices_y[::-1,:]
    if not rev_x: indices_x = indices_x[:, ::-1]

    off_a = indices_x + indices_y * slope
    off_b = indices_y + indices_x * slope

    if steep:
        axis = 0
        # construct a slope to simulate sun angle
        # elevations will be draped over this slope
        off = off_a[:, ::-1]

        src_y = indices_x [:,::-1]
        src_x = np.round(off_b).astype(int)

    else:
        axis = 1
        off = off_b[:, ::-1]

        src_x = indices_y
        src_y = np.round(off_a).astype(int)

    src = np.s_[src_y, src_x]

    # x + y gives horizontal distance on x (!)
    # for orhtogonal distance to slope prependicular,
    # we take cosine (given x+y is hypothenuse)
    off *= pixel_size * np.cos(np.radians(s)) * tilt

    # create a matrix to hold the sheared matrix
    mx_temp = np.zeros(((np.max(src_y)+1), np.max(src_x)+1))

    t_y, t_x = mx_temp.shape

    # carrying lines from one chunk to the next (fussy...)
    if steep:
        l = np.s_[-1  ,  : ysize ]
        f = np.s_[0  , t_x - ysize : ]
    else:
        l = np.s_[t_y - xsize :  , -1 ]
        f = np.s_[:xsize, 0   ]

    last_line = np.zeros(( ysize if steep else xsize))

  # 4 -----   LOOP THOUGH DATA CHUNKS AND CALCULATE -----------------
    counter = 0
    for dem_view, gdal_coords, unused_out, unused_gdal_out in window_loop (
        shape = (xsize, ysize),
        chunk = chunk,
        axis = not steep,
        reverse = rev_x if steep else rev_y,
        overlap= 0,
        offset = -1) :

        mx_z[dem_view]=dem.ReadAsArray(*gdal_coords).astype(float)

        # should handle better NoData !!
        # nans will destroy the accumulation sequence
        mask = mx_z == nodata
        mx_z[mask]= -9999

        mx_temp[src] = mx_z + off

        mx_temp[f] += -last_line # shadows have negative values, so *-1

    #accumulate maximum shadow depths
        mx_temp -= np.maximum.accumulate(mx_temp, axis= axis)

        # first line has shadow od zero depth (nothing to accum), so copy from previous chunk
        mx_temp[f] = last_line

        last_line [:] = mx_temp[l ] # save for later

        out = mx_temp[src]

        if smooth: out = filter3(out)

        out[mask]=np.nan

        ds.GetRasterBand(1).WriteArray(out[dem_view], * gdal_coords[:2])

        counter += 1

        print( 100 * chunk * counter / (xsize if steep else ysize))

    ds = None
    dem = None




